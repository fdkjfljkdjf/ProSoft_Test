class Foo
{
public:
    Foo(int j) { i=new int[j]; }
    ~Foo() { delete i; }
private:
     int* i;
};

class Bar: Foo
{
public:
    Bar(int j) { i=new char[j]; }
    ~Bar() { delete i; }
private:
    char* i;
};


void main()
{
    Foo* f=new Foo(100);
    Foo* b=new Bar(200);
    *f=*b;
    delete f;
    delete b;
}


/*

1) Для базового класса и класса наследника не прописаны конструкторы по умолчанию

2) В деструкторе необходимо писать "delete [] i", чтобы избежать утечек памяти

3) Рекомендуется использовать "nullptr" после освобождения памяти оператором "delete"

4) В строчке "Foo* b = new Bar(200);" указателю типа базового класса b присваивается ссылка
на объект дочернего класса, при этом выделяется динамически память. Так как указатель b типа Foo,
то при осовобождении ресурсов будет вызываться диструктор базового класса ~Foo(),
а нам нужен диструктор дочернего класса ~Bar(). Необходимо сделать диструктор виртуальным в базовом
классе virtual ~Foo()

5) В данном примере отсутствует код возврата. Необходимо дописать "return 0;" и заменить
"void main()" на "int main()"

6) Отсутствует проверка аргументов передаваймых в параметрический конструктор

7) сначала надо написать опреатор delete для объекта b, а затем для объекта f,
так как b является наследником класса f

8) после выполнения строки *f=*b два объекта ссылаются на одну и ту же область памяти.
Как следствие получим падение программы при выполнении delete b
*/